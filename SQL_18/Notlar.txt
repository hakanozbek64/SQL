18. ders:


örnek:(17dersteki son örnek devam)


calýþanlarýma prim ödeyecegim.prim ödemem gerek ilk  5 calýþan ...

bir önceki örnege benziyor.

düzenlersek firs name kýsmýný biz sectik uygun oldugunu düþünerek.

cevap:(caþýtýr)
select top 5 Employees.FirstName,SUM([Order Details].UnitPrice*Quantity) as kazanc from Employees join Orders on  Employees.EmployeeID=Orders.EmployeeID join [Order Details] on Orders.OrderID=[Order Details].OrderID group by Employees.FirstName order by kazanc desc


--------------------------------------


burada bir püf noktasý gösterelim:..


as kazanc gibi fromdan sonra emlpyes as e orders as o dersek bundan sonraki emloyes ve orderlarý kýsaltýlmýþ yazabiliriz.

yani þöyle:


select top 5 e.FirstName,SUM(od.UnitPrice*Quantity) as kazanc from Employees as e join Orders as o on e.EmployeeID=o.EmployeeID join [Order Details] as od on o.OrderID=od.OrderID group by e.FirstName order by kazanc desc


sonucta ayný sonucu elde ederiz.
-------------------
örnek:


hangi calýþan hangi calýþana baglýdýr?



acýklama:

alt üst meselesi(zýttý)
soruluyor
calýþan dedigi için employesleri alýcagýz.


diagrama bakarsak calýþanlardan calýþanlara bir yol var tam bizim aradýgýmýz mantýk..
burada tabiki tablos and colomn kýsmýnýda kullanacagýz.

eployees ve employees tablolarýný birleþtirisek.
select * from Employees as e join Employees as em on e.EmployeeID=em.ReportsTo

oluþur.

bunu þöyle düzenleyelim (istersek)

iki tane firsname kolonu oldugu için:

select e.FirstName,em.FirstName from Employees as e join Employees as em on e.EmployeeID=em.ReportsTo

burada baglý olanlarý nasýl gösterebiliriz.

select e.EmployeeID,e.FirstName,em.FirstName from Employees as e join Employees as em on e.EmployeeID=em.ReportsTo
ancak burda sýkýntý olabilir.bu örnekteki amac
 aþagýdaki komutu(left join) anlatmaktý

burada bir komuttan bahsedecegiz.


----------------------------------------------

--left join :birleþmenin solundaki null degeri dikkate alarak iþlem yapar.


--right join:birleþmenin solundaki null  degeri
dikkate alarak iþlem yapar. 

--full outer join: iki taraftan null u ekler.



------------------

yukarýdaki örnege geri dönersek :


örnekte:

hangi calýþan hangi calýþana baglýdýr? demiþtik

join yerine left join yazýcagýz.

ve düzenlersek:::

select e.EmployeeID,e.FirstName,em.FirstName from Employees as e left join Employees as em on e.EmployeeID=em.ReportsTo

yani ::
      employed ýd firstname  firstname
         1           nansc     null 

....................................
þeklinde devam ediyor


bunun anlamý nansc in üstü yok demektir.

left(sol)

right(sag)

istersek digerlerinide bu þekilde ayarlaya biliriz.


----------------------------------------------
örnek:



müþterilerin aldýgý sipariþlerin sayýsý nedir?




acýklama:

iki tabloyu birleþtiriyoruz her zmanki gibi



select * from Customers
select *from Orders


grup olarak þirket adýný alalým (
müþteri yerine )

þipariþlerini sayýsýný da sipariþlerdeki orderýd den bulabiliriz.

cevap:


select c.CompanyName,COUNT(o.OrderID) from Customers as c join Orders as o on c.CustomerID=o.CustomerID group by c.CompanyName


yada count kýsmýný

count kolonunun ismini (no clomn) sipariþsayýsý olarak degiþtirdik.


select c.CompanyName,COUNT(o.OrderID) as sipariþsayýsý from Customers as c join Orders as o on c.CustomerID=o.CustomerID group by c.CompanyName

***

ders sonu.






















































